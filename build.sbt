scalaVersion := "2.12.15"


lazy val processMapperAnnotations = taskKey[Unit]("Process Object Mapper annotations in compiled Scala classes")
lazy val compileMapperGeneratedSources = taskKey[Unit]("Compile the sources that were generated by the Object Mapper")

def runCommand(command: String, message: => String, log: Logger) {
    import scala.sys.process._

    val result = command !

    if (result != 0) {
        log.error(message)
        sys.error("Failed running command: " + command)
    }
}

lazy val model = project
  .settings(
//      libraryDependencies ++= Seq(
//          Dependencies.javaDriverMapperRuntime,
//          Dependencies.bcrypt,
//          Dependencies.javaDriverMapperProcessor % "provided"
//      ),

      processMapperAnnotations := {
          val log = streams.value.log

          log.info("Processing Object Mapper annotations in compiled Scala classes...")

          val classpath = ((Compile / products).value ++ (Compile / dependencyClasspath).value.files) mkString ":"
          val sourceDirectory = (Compile / classDirectory ).value
          val classesToProcess = (sourceDirectory ** "*.class")
            .getPaths()
            .map(_.stripPrefix(sourceDirectory.getAbsolutePath + "/").stripSuffix(".class").replaceAll("/", "."))
            .mkString(" ")
          val destinationDirectory = (Compile / sourceManaged).value / "mapper"
          destinationDirectory.mkdirs()

          val processor = "com.datastax.oss.driver.internal.mapper.processor.MapperProcessor"

          val command =
              s"""javac
                 | -classpath $classpath
                 | -proc:only -processor $processor
                 | -d $destinationDirectory
                 | $classesToProcess""".stripMargin
          runCommand(command, "Failed to run Object Mapper processor", log)

          log.info("Done processing Object Mapper annotations in compiled Scala classes")
      },

      compileMapperGeneratedSources := {
          val log = streams.value.log

          log.info("Compiling Object Mapper generated sources...")

          val classpath = ((Compile / products).value ++ (Compile / dependencyClasspath).value.files) mkString ":"
          val sourceDirectory = (Compile / sourceManaged).value / "app" / "models" / "cassandra"
          val javaSources = (sourceDirectory ** "*.java").getPaths().mkString(" ")

          // TODO there's probably a better way than invoking javac manually
          val command =
              s"""javac
                 | -classpath $classpath
                 | -d ${(Compile / classDirectory).value}
                 | $javaSources""".stripMargin
          runCommand(command, "Failed to compile mapper-generated sources", log)

          log.info("Done compiling Object Mapper generated sources")
      },

      Compile / compileMapperGeneratedSources := (Compile / compileMapperGeneratedSources dependsOn (Compile / processMapperAnnotations)).value,

      Compile / packageBin := (Compile / packageBin dependsOn (Compile / compileMapperGeneratedSources)).value
  )

lazy val main = (project in file("."))
  .dependsOn(model)
  .enablePlugins(SbtWeb)
  .enablePlugins(PlayJava)
  .settings(
    ivyLoggingLevel := UpdateLogging.Quiet,
    Assets / sourceDirectory := baseDirectory.value / "app/assets",
    Assets / resourceDirectory  := baseDirectory.value / "public",
    target := baseDirectory.value / "target/sbt",
    gzip / includeFilter := "*",
    pipelineStages := Seq(digest, gzip)
  )

// add development mode run hook which starts webpack file watcher (./project/webpack.scala)
PlayKeys.playRunHooks += Webpack(baseDirectory.value)
// include webpack output js files in the public assets
Assets / unmanagedResourceDirectories += target.value / "webpack"
